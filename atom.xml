<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DecodeZ</title>
  
  <subtitle>刚日读经，柔日读史</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://decodezp.github.io/"/>
  <updated>2019-08-25T14:16:29.701Z</updated>
  <id>https://decodezp.github.io/</id>
  
  <author>
    <name>Pan Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Quickwords33:How uprobe works</title>
    <link href="https://decodezp.github.io/2019/08/25/quickwords33-how-uprobe-work/"/>
    <id>https://decodezp.github.io/2019/08/25/quickwords33-how-uprobe-work/</id>
    <published>2019-08-25T14:07:45.000Z</published>
    <updated>2019-08-25T14:16:29.701Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;用uprobe也有一段时间了，确实是一个很有价值的工具。我这个人有个特点，就是如果不知道这件事背后的原理，即便工具很好用，但用起来始终心里不踏实，像是房本上没加名字，住着没有安全感。对于uprobe这么fancy的工具还是很有必要了解一下具体的工作机制。一方面是打消“神秘感”，一方面是看看是否能激发别的灵感。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>十八岁这天的日记</title>
    <link href="https://decodezp.github.io/2019/08/11/diary-on-18th-b-day/"/>
    <id>https://decodezp.github.io/2019/08/11/diary-on-18th-b-day/</id>
    <published>2019-08-11T08:48:30.000Z</published>
    <updated>2019-08-11T08:49:56.476Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;上中学的时候，按历任语文老师的要求，写过好几本日记。这里面有一本是最不一样的，因为高三了，语文老师可能也认为“写日记”这个事确实太闲情逸致了一些，所以不再像以前一样要求上交日记本批改。我因此也得以在上面写了一些真正的日记。&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>几句话说清楚32：Git命令极简使用指南</title>
    <link href="https://decodezp.github.io/2019/08/09/quickwords32-simplest-git-manual/"/>
    <id>https://decodezp.github.io/2019/08/09/quickwords32-simplest-git-manual/</id>
    <published>2019-08-09T13:23:45.000Z</published>
    <updated>2019-08-09T13:29:49.412Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本上可以Cover 90%以上的工作场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;要开始在现有Master上搞点什么&quot;&gt;&lt;a href=&quot;#要开始在现有Master上搞点什么&quot; class=&quot;headerlink&quot; title=&quot;要开始在现有Master上搞点什么&quot;&gt;&lt;/a&gt;要开始在现有Master上搞点什么&lt;/h2&gt;&lt;h3 id=&quot;确保你在master分支上&quot;&gt;&lt;a href=&quot;#确保你在master分支上&quot; class=&quot;headerlink&quot; title=&quot;确保你在master分支上&quot;&gt;&lt;/a&gt;确保你在master分支上&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git checkout master&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去18：使用LD_PRELOAD搞砸一切</title>
    <link href="https://decodezp.github.io/2019/08/09/test18-ld-preload-mess-up/"/>
    <id>https://decodezp.github.io/2019/08/09/test18-ld-preload-mess-up/</id>
    <published>2019-08-08T21:19:53.000Z</published>
    <updated>2019-08-08T21:22:32.702Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LD-PRELOAD&quot;&gt;&lt;a href=&quot;#LD-PRELOAD&quot; class=&quot;headerlink&quot; title=&quot;LD_PRELOAD&quot;&gt;&lt;/a&gt;LD_PRELOAD&lt;/h2&gt;&lt;p&gt;&lt;code&gt;LD_PRELOAD&lt;/code&gt;是一个神奇的指令，关于它的介绍可以参考这篇&lt;a href=&quot;http://www.goldsborough.me/c/low-level/kernel/2016/08/29/16-48-53-the_-ld_preload-_trick/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，这篇&lt;a href=&quot;https://catonmat.net/simple-ld-preload-tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去17：Adding dynamic probe to gain insight of DPDK application</title>
    <link href="https://decodezp.github.io/2019/08/07/test17-dyn-probe-dpdk/"/>
    <id>https://decodezp.github.io/2019/08/07/test17-dyn-probe-dpdk/</id>
    <published>2019-08-07T11:00:53.000Z</published>
    <updated>2019-08-07T11:02:23.302Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dynamic-Trace-Framework&quot;&gt;&lt;a href=&quot;#Dynamic-Trace-Framework&quot; class=&quot;headerlink&quot; title=&quot;Dynamic Trace Framework&quot;&gt;&lt;/a&gt;Dynamic Trace Framework&lt;/h2&gt;&lt;p&gt;曾经想给DPDK添加一个trace framework，但使用的方法是添加一个专门的rte_trace库，涉及一整套trace buffer和控制相关的操作，同时需要修改原本DPDK应用的代码，使用起来成本还是比较高的。在逐渐熟悉了&lt;code&gt;uprobe&lt;/code&gt;的操作之后，其实可以用uprobe完成绝大部分这个trace framework所做的工作，例如方法执行时间戳、方法参数、返回值、内部变量值的记录工作，并且有性能开销方面的保障。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去16：Adding new kprobe to ftrace tracing</title>
    <link href="https://decodezp.github.io/2019/07/19/test16-adding-new-kprobe/"/>
    <id>https://decodezp.github.io/2019/07/19/test16-adding-new-kprobe/</id>
    <published>2019-07-19T12:29:10.000Z</published>
    <updated>2019-07-19T12:30:11.824Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;添加ftrace新事件&quot;&gt;&lt;a href=&quot;#添加ftrace新事件&quot; class=&quot;headerlink&quot; title=&quot;添加ftrace新事件&quot;&gt;&lt;/a&gt;添加ftrace新事件&lt;/h2&gt;&lt;p&gt;Ftrace自己带很多事件，之前一直以为在内核方面ftrace的触角就到此为止了。今天才了解到kprobe也可以像uprobe一样自己动态定义一个出来。这样默认的ftrace没有的事件也就可以通过添加新kprobe事件的方式添加了。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去15：DPDK VxLAN Inner L4 CSUM OFFLOAD</title>
    <link href="https://decodezp.github.io/2019/07/16/test15-dpdk-vxlan-csum-offload/"/>
    <id>https://decodezp.github.io/2019/07/16/test15-dpdk-vxlan-csum-offload/</id>
    <published>2019-07-16T11:08:19.000Z</published>
    <updated>2019-07-16T11:14:22.339Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IXGBE&quot;&gt;&lt;a href=&quot;#IXGBE&quot; class=&quot;headerlink&quot; title=&quot;IXGBE&quot;&gt;&lt;/a&gt;IXGBE&lt;/h2&gt;&lt;p&gt;以IXGBE驱动为例，看一下如何让把内层报文Checksum的计算Offload给网卡。&lt;/p&gt;
&lt;p&gt;本质上来说，是在DPDK的&lt;code&gt;mbuf&lt;/code&gt;结构中，将L2 Header的长度配置为外层VxLAN报文+内层L2 Header的总长度，这样对网卡来说，该&lt;code&gt;mbuf&lt;/code&gt;对应的报文就是一个L2 Header长得令人发指的普通非隧道报文，但是这样就可以计算内层L3/L4 Header的Checksum了。&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="https://decodezp.github.io/categories/test/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="dpdk" scheme="https://decodezp.github.io/tags/dpdk/"/>
    
      <category term="test" scheme="https://decodezp.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Quickwords31：What Is Inclusive and Exclusive Cache</title>
    <link href="https://decodezp.github.io/2019/07/08/quickwords31-inclusive-exclusive-cache/"/>
    <id>https://decodezp.github.io/2019/07/08/quickwords31-inclusive-exclusive-cache/</id>
    <published>2019-07-08T13:10:13.000Z</published>
    <updated>2019-07-08T13:23:30.705Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一般对Cache的认知方式&quot;&gt;&lt;a href=&quot;#一般对Cache的认知方式&quot; class=&quot;headerlink&quot; title=&quot;一般对Cache的认知方式&quot;&gt;&lt;/a&gt;一般对Cache的认知方式&lt;/h2&gt;&lt;p&gt;我们比较熟悉的对Cache的理解是，首先有3级，L1，L2和L3。这三级依次远离CPU核心，查询数据的速度也依次减慢。当CPU需要一个地址上的数据时，会先去L1查找；当L1没有这个数据的时候，去L2查找；L2也没有的时候，去L3查找。如果还没有，就去内存上去查找。这是我们看待Cache和CPU查询数据时的一般方式。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="hardware" scheme="https://decodezp.github.io/tags/hardware/"/>
    
      <category term="CPU" scheme="https://decodezp.github.io/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>应许之日</title>
    <link href="https://decodezp.github.io/2019/06/24/promised-date/"/>
    <id>https://decodezp.github.io/2019/06/24/promised-date/</id>
    <published>2019-06-24T14:05:19.000Z</published>
    <updated>2019-06-24T14:06:29.586Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;很庆幸自己能活这么久，站在此时此刻的人生节点上，可以闻到更好的时光还在后面。&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>5分钟经典英文技术演讲3：如何应对信息过载并提高生产效率-Scott Hanselman</title>
    <link href="https://decodezp.github.io/2019/06/19/eng-talk3-scaling-yourself/"/>
    <id>https://decodezp.github.io/2019/06/19/eng-talk3-scaling-yourself/</id>
    <published>2019-06-19T12:04:22.000Z</published>
    <updated>2019-06-19T12:06:15.239Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个人的能力上限很大程度上取决于他获取信息的能力。&lt;/p&gt;
&lt;p&gt;而能力增长的速度与获取信息的&lt;strong&gt;质量&lt;/strong&gt;正相关。&lt;/p&gt;
&lt;p&gt;不可否认，大量优质的技术内容都基于英文。“5分钟经典英文技术演讲”专门撷取国外最有价值的纯英文技术演讲，以最精炼的形式将信息传达给国内的技术同侪，绕过网络政策和语言的障碍，实现中西方技术世界无壁垒的信息同步。&lt;/p&gt;
&lt;p&gt;最新内容将发布于DecodeZ: decodezp.github.io&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://decodezp.github.io/2018/12/12/eng-talk1-fast-learn/&quot;&gt;往期回顾1：如何快速掌握新技术&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://decodezp.github.io/2018/12/21/eng-talk2-things-matter/&quot;&gt;往期回顾2：软件设计真正的精髓&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;GOTO2012-Scaling-Yourself&quot;&gt;&lt;a href=&quot;#GOTO2012-Scaling-Yourself&quot; class=&quot;headerlink&quot; title=&quot;GOTO2012: Scaling Yourself&quot;&gt;&lt;/a&gt;GOTO2012: Scaling Yourself&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=FS1mnISoG7U&amp;amp;list=PL-V4m0AO-7weBsEkJjmF563WGfIsCgk9t&amp;amp;index=16&amp;amp;t=1484s&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hanselman.com/blog/content/binary/Windows-Live-Writer/0a3df681baef_C924/97e47e1feb7b591e8220b08a8c83cc9a_28706943-45af-44b8-a280-d15e7cfbc89c.jpg&quot; alt=&quot;演讲者：Scott Hanselman&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;摘要：信息过载的时代，能否找到一种在信息洪流中独善其身的方法，让我们专注于真正重要事情？当生活/工作的范畴一再扩大，我们也需要延展自身的边界，在充分利用信息的同时，保持持续的生产效率。&lt;br&gt;
    
    </summary>
    
      <category term="ENG_talk" scheme="https://decodezp.github.io/categories/ENG-talk/"/>
    
    
      <category term="English" scheme="https://decodezp.github.io/tags/English/"/>
    
      <category term="Presentation" scheme="https://decodezp.github.io/tags/Presentation/"/>
    
  </entry>
  
  <entry>
    <title>Quickwords30：Use Both kprobe and uprobe At The Same Time</title>
    <link href="https://decodezp.github.io/2019/06/18/quickwords30-kprobe-uprobe-both/"/>
    <id>https://decodezp.github.io/2019/06/18/quickwords30-kprobe-uprobe-both/</id>
    <published>2019-06-18T13:37:51.000Z</published>
    <updated>2019-06-18T13:40:34.912Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;用&lt;code&gt;ftrace&lt;/code&gt;可以观察内核方法的调用信息。用&lt;code&gt;uprobe&lt;/code&gt;可以观察用户空间二进制可执行文件中方法的调用信息。奇怪的是当你想把两个合在一起用的时候，比如你想看到内核调度器调度到了你关心的用户进程，同时也想知道调度之后，该进程会执行哪个方法的时候，网络上我没有找到任何资料教你如何去做。按说这应该是一个对各类系统问题诊断很有用的能力。&lt;/p&gt;
&lt;p&gt;也许是太简单了？下面用一个示例说明。&lt;/p&gt;
&lt;h2 id=&quot;内核版本&quot;&gt;&lt;a href=&quot;#内核版本&quot; class=&quot;headerlink&quot; title=&quot;内核版本&quot;&gt;&lt;/a&gt;内核版本&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;uname -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.19.6-1.el7.elrepo.x86_64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有点新，不过不害事。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Quickwords29：AMD ZEN 2 Microarchitecture Overview</title>
    <link href="https://decodezp.github.io/2019/06/12/quickwords29-amd-zen2-microarch/"/>
    <id>https://decodezp.github.io/2019/06/12/quickwords29-amd-zen2-microarch/</id>
    <published>2019-06-11T21:59:06.000Z</published>
    <updated>2019-06-11T22:00:23.427Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AMD-ZEN-2&quot;&gt;&lt;a href=&quot;#AMD-ZEN-2&quot; class=&quot;headerlink&quot; title=&quot;AMD ZEN 2&quot;&gt;&lt;/a&gt;AMD ZEN 2&lt;/h2&gt;&lt;p&gt;在消费者和服务器市场AMD推出了全新的基于ZEN 2微架构的处理器，包括Ryzen 3000系列和EPYC系列。在市场宣传方面均给出了高于Intel竞品处理器的性能。我这里还没有拿到实际的产品进行性能测试，但可以先从公开的微架构设计的角度看一看AMD这款新产品的大体思路。&lt;/p&gt;
&lt;h2 id=&quot;Microarchitecture-Overview&quot;&gt;&lt;a href=&quot;#Microarchitecture-Overview&quot; class=&quot;headerlink&quot; title=&quot;Microarchitecture Overview&quot;&gt;&lt;/a&gt;Microarchitecture Overview&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://images.anandtech.com/doci/14525/Mike_Clark-Next_Horizon_Gaming-CPU_Architecture_06092019-page-003.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是ZEN 2产品的微架构示意图。从微架构的“架构”设计上，感觉业界基本上遵从了同一套模式，很难有创新和突破。均是基于以下三个部分：&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="hardware" scheme="https://decodezp.github.io/tags/hardware/"/>
    
      <category term="CPU" scheme="https://decodezp.github.io/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>拔智齿</title>
    <link href="https://decodezp.github.io/2019/06/05/tooth-extraction/"/>
    <id>https://decodezp.github.io/2019/06/05/tooth-extraction/</id>
    <published>2019-06-05T12:02:29.000Z</published>
    <updated>2019-06-05T12:09:14.412Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;拔智齿是一个磨人的过程。真正拔的时候其实还好，但决定去拔之前，要做很多心理建设工作。尤其是对牙一直很好的人来说，去拔牙就仿佛承认了之前对牙齿的乐观和与之俱来的优越感都只是一场幻觉。&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="https://decodezp.github.io/categories/life/"/>
    
    
      <category term="life" scheme="https://decodezp.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Gartner预测误差统计</title>
    <link href="https://decodezp.github.io/2019/06/03/gartner-prediction/"/>
    <id>https://decodezp.github.io/2019/06/03/gartner-prediction/</id>
    <published>2019-06-03T12:30:27.000Z</published>
    <updated>2019-06-03T12:45:59.771Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Gartner的预测&quot;&gt;&lt;a href=&quot;#Gartner的预测&quot; class=&quot;headerlink&quot; title=&quot;Gartner的预测&quot;&gt;&lt;/a&gt;Gartner的预测&lt;/h2&gt;&lt;p&gt;Gartner表面上是一家咨询公司，实际上是一家市场公关公司。不仅通过一些市场工具给厂商打广告，还直接给某样技术打广告，当然也兼做一些资源对接的中介服务。至于Gartner的分析报告，即便每年需要几十万的“咨询费”才能阅读，但我是从来没有完整看完过其中任何一篇，因为他们报告的题目都拟得非常好——非常精炼，也非常准确——所以有时候看完题目就好了。&lt;/p&gt;
&lt;p&gt;每当Gartner新公布了一项市场数字和指标之后，都会被各家媒体和相关厂商疯狂引用，作为论证市场繁荣和增长预期的最有力论据。但年复一年，我们永远盯住的是“下一个丰收的年景”，却不怎么关心当下的市场是否曾被准确勾画。以往知来，我们就以年年火热的云计算市场为例，统计一下Gartner的历史预测准确率。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去14：Phoronix tinymembench结果不理想的可能原因</title>
    <link href="https://decodezp.github.io/2019/05/28/test14-phoronix-tinymembench/"/>
    <id>https://decodezp.github.io/2019/05/28/test14-phoronix-tinymembench/</id>
    <published>2019-05-28T12:44:02.000Z</published>
    <updated>2019-05-28T12:46:16.404Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Phoronix-tinymembench&quot;&gt;&lt;a href=&quot;#Phoronix-tinymembench&quot; class=&quot;headerlink&quot; title=&quot;Phoronix tinymembench&quot;&gt;&lt;/a&gt;Phoronix tinymembench&lt;/h2&gt;&lt;p&gt;这个测试经常用来衡量CPU&lt;code&gt;memcpy&lt;/code&gt;和&lt;code&gt;memset&lt;/code&gt;这两个基本操作的性能。最近在执行针对两款CPU的性能测试中，发现某款相对”高端“的CPU在这两个测试中表现与相对“低端”的CPU相比，存在较大差距。&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="https://decodezp.github.io/categories/test/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="test" scheme="https://decodezp.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>测来测去13：DPDK i40e X710 FDIR Flexbytes</title>
    <link href="https://decodezp.github.io/2019/05/23/test13-dpdk-x710-flexload/"/>
    <id>https://decodezp.github.io/2019/05/23/test13-dpdk-x710-flexload/</id>
    <published>2019-05-23T12:42:12.000Z</published>
    <updated>2019-05-28T12:46:18.398Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flex-Bytes&quot;&gt;&lt;a href=&quot;#Flex-Bytes&quot; class=&quot;headerlink&quot; title=&quot;Flex Bytes&quot;&gt;&lt;/a&gt;Flex Bytes&lt;/h2&gt;&lt;p&gt;700系列网卡除了提取包头的字段作为散列的依据之外，还可以截取Payload的特定片段作为散列的依据。&lt;/p&gt;
&lt;p&gt;Flexible payload是可以识别出的L2/L3/L4 Header之后的字节，最多可以截取来自于3个不同偏移（OFFSET）的16字节内容。所有的内容需要来自该报文前480字节内。&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="https://decodezp.github.io/categories/test/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="test" scheme="https://decodezp.github.io/tags/test/"/>
    
      <category term="NIC" scheme="https://decodezp.github.io/tags/NIC/"/>
    
  </entry>
  
  <entry>
    <title>统治者为什么会重复犯同样的错误</title>
    <link href="https://decodezp.github.io/2019/05/22/thoughts9-identical-behavior/"/>
    <id>https://decodezp.github.io/2019/05/22/thoughts9-identical-behavior/</id>
    <published>2019-05-22T12:22:22.000Z</published>
    <updated>2019-05-22T12:23:35.058Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;史书上对自己作死的亡国之君的描述基本上都是类似的。用查找替换把两个名字换一下，基本不影响阅读体验。&lt;/p&gt;
&lt;p&gt;奇怪的点就在于，从第二个亡国之君开始，为什么明明知道已有“亡国之兆”，却仍然不加收敛？&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>Quickwords28：Skylake Microarchitecture(11)</title>
    <link href="https://decodezp.github.io/2019/05/18/quickwords28-skylake-pipeline-11/"/>
    <id>https://decodezp.github.io/2019/05/18/quickwords28-skylake-pipeline-11/</id>
    <published>2019-05-18T07:48:31.000Z</published>
    <updated>2019-05-18T07:49:50.035Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Store-and-Load-Example&quot;&gt;&lt;a href=&quot;#Store-and-Load-Example&quot; class=&quot;headerlink&quot; title=&quot;Store and Load Example&quot;&gt;&lt;/a&gt;Store and Load Example&lt;/h2&gt;&lt;p&gt;Given the initialized situation like this:&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="hardware" scheme="https://decodezp.github.io/tags/hardware/"/>
    
      <category term="CPU" scheme="https://decodezp.github.io/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>测来测去12：DPDK i40e X710 Flow Director Deep Dive(3)</title>
    <link href="https://decodezp.github.io/2019/05/14/test12-dpdk-x710-fdir-mask-3/"/>
    <id>https://decodezp.github.io/2019/05/14/test12-dpdk-x710-fdir-mask-3/</id>
    <published>2019-05-14T11:02:43.000Z</published>
    <updated>2019-05-14T11:05:20.204Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多于两个input-set的mask&quot;&gt;&lt;a href=&quot;#多于两个input-set的mask&quot; class=&quot;headerlink&quot; title=&quot;多于两个input_set的mask&quot;&gt;&lt;/a&gt;多于两个&lt;code&gt;input_set&lt;/code&gt;的mask&lt;/h2&gt;&lt;p&gt;先说结论，一个&lt;code&gt;pctype&lt;/code&gt;可以设置多个&lt;code&gt;input_set&lt;/code&gt;，但是最多仅能给两个&lt;code&gt;input_set&lt;/code&gt;设置mask。&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="https://decodezp.github.io/categories/test/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="test" scheme="https://decodezp.github.io/tags/test/"/>
    
      <category term="NIC" scheme="https://decodezp.github.io/tags/NIC/"/>
    
  </entry>
  
  <entry>
    <title>测来测去11：DPDK i40e X710 Flow Director Deep Dive(2)</title>
    <link href="https://decodezp.github.io/2019/05/13/test11-dpdk-x710-fdir-mask-2/"/>
    <id>https://decodezp.github.io/2019/05/13/test11-dpdk-x710-fdir-mask-2/</id>
    <published>2019-05-13T10:46:49.000Z</published>
    <updated>2019-05-13T10:51:29.452Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同时添加一个TCP-Flow-Director规则&quot;&gt;&lt;a href=&quot;#同时添加一个TCP-Flow-Director规则&quot; class=&quot;headerlink&quot; title=&quot;同时添加一个TCP Flow Director规则&quot;&gt;&lt;/a&gt;同时添加一个TCP Flow Director规则&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://decodezp.github.io/2019/05/11/test10-dpdk-x710-fdir-mask-1/&quot;&gt;上一篇文章&lt;/a&gt;的基础上，添加一个TCP相关的Fdir操作：&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="https://decodezp.github.io/categories/test/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="test" scheme="https://decodezp.github.io/tags/test/"/>
    
      <category term="NIC" scheme="https://decodezp.github.io/tags/NIC/"/>
    
  </entry>
  
</feed>
