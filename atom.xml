<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DecodeZ</title>
  
  <subtitle>刚日读经，柔日读史</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://decodezp.github.io/"/>
  <updated>2019-12-22T16:09:17.738Z</updated>
  <id>https://decodezp.github.io/</id>
  
  <author>
    <name>Pan Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几句话说清楚37:Skylake Non-inclusive缓存和Snoop Filter的关系</title>
    <link href="https://decodezp.github.io/2019/12/23/quickwords37-skylake-cache-snoop-filter/"/>
    <id>https://decodezp.github.io/2019/12/23/quickwords37-skylake-cache-snoop-filter/</id>
    <published>2019-12-22T16:05:40.000Z</published>
    <updated>2019-12-22T16:09:17.738Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Skylake的缓存设计使用了Non-inclusive的架构设计，同时调大了L2缓存的大小。简单来说，区别就是以前从内存读入的数据会同时进入L3和L2缓存，而现在会只进入L2缓存，当该数据从L2缓存中清除的时候，才会进入L3缓存。&lt;/p&gt;
&lt;p&gt;在以前的缓存架构中，L2缓存中的数据是L3缓存数据的真子集。而Skylake的架构中，L2和L3的数据在绝大部分时间中是独占的(exclusive)的，即二者所缓存的数据没有重叠。但注意，Skylake的架构是Non-inclusive，而不是严格的exclusive，是因为当同一条Cache Line在多个CPU核的L2缓存中都存在时，L3缓存中也有该Cache Line的数据。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="perf" scheme="https://decodezp.github.io/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>怎样讲一个好故事</title>
    <link href="https://decodezp.github.io/2019/12/22/thoughts12-how-to-make-a-good-story/"/>
    <id>https://decodezp.github.io/2019/12/22/thoughts12-how-to-make-a-good-story/</id>
    <published>2019-12-22T14:26:27.000Z</published>
    <updated>2019-12-22T14:28:09.705Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;   人的一切知识和学问都是从故事中获取的。讲故事不仅仅是人类传承知识和文化的手段，同时也是获得理解和支持的最有效的方式。并且，一个经过设计(Engineered)的故事具备以虚驭实的能力，这种一种让人着迷的力量。怎样讲出一个好的故事，就是这篇文章想要讲的故事。&lt;/p&gt;
&lt;p&gt;所有故事都有一个开头，这个开头的作用不在于交代背景，也不在于用离奇的描述“抓住眼球”，而在于将读者代入到故事中去。一定要出现读者所熟悉的元素、符号、场景和经历，或者没有直接出现，但能够激发读者去联想，去自己的认知库中检索和关联的意象。&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>快乐清单</title>
    <link href="https://decodezp.github.io/2019/12/05/thoughts11-happiness-list/"/>
    <id>https://decodezp.github.io/2019/12/05/thoughts11-happiness-list/</id>
    <published>2019-12-04T23:08:49.000Z</published>
    <updated>2019-12-04T23:12:11.358Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;开始了一项早就打算开始的项目：把每天快乐的瞬间都记录下来。Google Drive中这个简单的Excel表格，被我命名为“快乐清单”。&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>测来测去22：DPDK i40e fdir+rss+reta实现相同flow type不同input_set散列</title>
    <link href="https://decodezp.github.io/2019/11/26/test22-fdir-rss-reta/"/>
    <id>https://decodezp.github.io/2019/11/26/test22-fdir-rss-reta/</id>
    <published>2019-11-26T11:07:58.000Z</published>
    <updated>2019-11-26T11:12:07.218Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;i40e网卡，同样的flow type，比如&lt;code&gt;RTE_ETH_FLOW_NONFRAG_IPV4_UDP&lt;/code&gt;，需求是某一特定Dst Port的报文到rx队列1，某一特定Src IP + Dst IP的报文到rx队列2，或其他类似的针对相同flow type的需求。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>怎样做好市场工作</title>
    <link href="https://decodezp.github.io/2019/11/17/thoughts10-how-to-do-marketing/"/>
    <id>https://decodezp.github.io/2019/11/17/thoughts10-how-to-do-marketing/</id>
    <published>2019-11-17T09:34:32.000Z</published>
    <updated>2019-11-17T09:37:28.667Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;市场工作是提高产品价值所要进行的最重要的工作。市场工作并不是围绕产品的工作，也不是围绕客户的工作，而是围绕&lt;strong&gt;符号&lt;/strong&gt;的工作——构建关于一个特定符号的意象。这个符号代表你想要卖出去的东西，而意象的作用在于，它不会改变人们对你产品的认知，而是让人们改变对&lt;strong&gt;自我&lt;/strong&gt;的认知，即便那只是一种想象。&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>QuickWords 35： Perf probe usage</title>
    <link href="https://decodezp.github.io/2019/11/07/quickwords35-perf-probe-usage/"/>
    <id>https://decodezp.github.io/2019/11/07/quickwords35-perf-probe-usage/</id>
    <published>2019-11-07T10:50:46.000Z</published>
    <updated>2019-11-07T10:55:13.411Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;查看用户空间binary/.so文件可用函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perf probe -F -x /usr/lib64/libopenvswitch-2.so.7.0.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看可以被probe的源码行&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="perf" scheme="https://decodezp.github.io/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>Loadbalancer Product Trends</title>
    <link href="https://decodezp.github.io/2019/10/31/product2-loadbalancer-trends/"/>
    <id>https://decodezp.github.io/2019/10/31/product2-loadbalancer-trends/</id>
    <published>2019-10-31T11:37:18.000Z</published>
    <updated>2019-10-31T11:41:44.054Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;So what is going on? There are mainly 4 kinds of work.&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
      <category term="product" scheme="https://decodezp.github.io/categories/tech/product/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="product" scheme="https://decodezp.github.io/tags/product/"/>
    
      <category term="network" scheme="https://decodezp.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>测来测去21：在ftrace中拿到event的user-space stack trace</title>
    <link href="https://decodezp.github.io/2019/10/30/test21-uprobe-userstacktrace/"/>
    <id>https://decodezp.github.io/2019/10/30/test21-uprobe-userstacktrace/</id>
    <published>2019-10-30T11:24:43.000Z</published>
    <updated>2019-10-30T11:27:33.509Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在开启了ftrace中的一些事件之后，可以用function_graph的trace拿到在&lt;strong&gt;&lt;em&gt;内核态&lt;/em&gt;&lt;/strong&gt;的callstack。但有些时候我们希望能拿到用户态程序的callstack，这样我们就能知道是那些方法触发了某一事件，或者我们直接希望uprobe的事件发生时，能够看到该事件对应的callstack，也会是一个很有价值的信息。&lt;/p&gt;
&lt;h2 id=&quot;阅读文档&quot;&gt;&lt;a href=&quot;#阅读文档&quot; class=&quot;headerlink&quot; title=&quot;阅读文档&quot;&gt;&lt;/a&gt;阅读文档&lt;/h2&gt;&lt;p&gt;本来的计划是，搞一个什么ftrace callback的内核模块，模块里面调用一些&lt;code&gt;save_stack_trace_user()&lt;/code&gt;这类的方法，但是感觉虽然理论上行得通，但是实际上系统里敢让你塞一个内核模块进去的企业太少，所以暂时先放弃这个方案。&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="https://decodezp.github.io/categories/test/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="test" scheme="https://decodezp.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>QuickWords 34： DPDK i40e 82599网卡发送Tx丢包问题</title>
    <link href="https://decodezp.github.io/2019/10/17/quickwords34-dpdk-tx-hang/"/>
    <id>https://decodezp.github.io/2019/10/17/quickwords34-dpdk-tx-hang/</id>
    <published>2019-10-16T19:11:39.000Z</published>
    <updated>2019-10-16T19:13:08.276Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;表现为在DPDK场景下网卡丢包或者发送队列Hang住。如果用GDB跟进去的话会发现是网卡的DD标志位未置位。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="hardware" scheme="https://decodezp.github.io/tags/hardware/"/>
    
      <category term="NIC" scheme="https://decodezp.github.io/tags/NIC/"/>
    
  </entry>
  
  <entry>
    <title>金罍深深酌</title>
    <link href="https://decodezp.github.io/2019/10/12/leuven-mem/"/>
    <id>https://decodezp.github.io/2019/10/12/leuven-mem/</id>
    <published>2019-10-12T12:33:29.000Z</published>
    <updated>2019-10-12T12:36:10.851Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h1&gt;&lt;p&gt;2012年3月，我在布鲁塞尔南站7号站台见到了高中同学L。&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="https://decodezp.github.io/categories/life/"/>
    
    
      <category term="life" scheme="https://decodezp.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Shell命令行中感叹号!的运用</title>
    <link href="https://decodezp.github.io/2019/09/25/exclamation-mark-shell/"/>
    <id>https://decodezp.github.io/2019/09/25/exclamation-mark-shell/</id>
    <published>2019-09-25T12:10:27.000Z</published>
    <updated>2019-09-25T12:19:29.469Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;重复执行上一条命令&quot;&gt;&lt;a href=&quot;#重复执行上一条命令&quot; class=&quot;headerlink&quot; title=&quot;!!重复执行上一条命令&quot;&gt;&lt;/a&gt;!!重复执行上一条命令&lt;/h2&gt;&lt;p&gt;直接输入&lt;code&gt;!!&lt;/code&gt;，不过我更喜欢按上方向键…&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>热烈庆祝8总力克猫传腹病魔康复痊愈</title>
    <link href="https://decodezp.github.io/2019/09/22/8-recovery/"/>
    <id>https://decodezp.github.io/2019/09/22/8-recovery/</id>
    <published>2019-09-22T10:50:13.000Z</published>
    <updated>2019-09-22T10:53:01.346Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;8总是今年3月出生的一只蓝白相间的英国短毛猫，因为脑袋上的蓝色花斑从中间裂开一个“八”字形的缝，因此被称为8总。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/22/u93Xm4.jpg&quot; alt=&quot;8总和母亲&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>测来测去20：快速定位short-lived进程对性能的负面影响</title>
    <link href="https://decodezp.github.io/2019/09/19/test20-troubleshoot-short-lived-process/"/>
    <id>https://decodezp.github.io/2019/09/19/test20-troubleshoot-short-lived-process/</id>
    <published>2019-09-18T19:58:10.000Z</published>
    <updated>2019-09-18T20:00:07.840Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h2&gt;&lt;p&gt;遇到过的一个案例是这样：DPDK应用在小流量的情况下丢包，并且是间歇性地丢。很自然的，会怀疑有其他进程抢占分配给DPDK的CPU核。&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="https://decodezp.github.io/categories/test/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
      <category term="test" scheme="https://decodezp.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>测来测去19：Enable DPDK i40e vector rx function</title>
    <link href="https://decodezp.github.io/2019/09/04/test19-enable-dpdk-i40e-vector-rx-function/"/>
    <id>https://decodezp.github.io/2019/09/04/test19-enable-dpdk-i40e-vector-rx-function/</id>
    <published>2019-09-04T11:22:57.000Z</published>
    <updated>2019-09-04T11:25:57.562Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vector-Rx-Function&quot;&gt;&lt;a href=&quot;#Vector-Rx-Function&quot; class=&quot;headerlink&quot; title=&quot;Vector Rx Function&quot;&gt;&lt;/a&gt;Vector Rx Function&lt;/h2&gt;&lt;p&gt;在DPDK i40e网卡的驱动中提供有利用向量指令收包的方法，在一般场景下可以大幅提升性能。当针对基于DPDK的应用做性能诊断时可以用&lt;code&gt;perf top&lt;/code&gt;命令直观观察有没有&lt;code&gt;i40e_recv_pkts_vec&lt;/code&gt;这个方法出现，如果没有则可以判定当前的应用没有使用向量指令集优化过的收/发包方法。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>Quickwords33:How uprobe works</title>
    <link href="https://decodezp.github.io/2019/08/25/quickwords33-how-uprobe-work/"/>
    <id>https://decodezp.github.io/2019/08/25/quickwords33-how-uprobe-work/</id>
    <published>2019-08-25T14:07:45.000Z</published>
    <updated>2019-08-25T14:16:29.701Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;用uprobe也有一段时间了，确实是一个很有价值的工具。我这个人有个特点，就是如果不知道这件事背后的原理，即便工具很好用，但用起来始终心里不踏实，像是房本上没加名字，住着没有安全感。对于uprobe这么fancy的工具还是很有必要了解一下具体的工作机制。一方面是打消“神秘感”，一方面是看看是否能激发别的灵感。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>十八岁这天的日记</title>
    <link href="https://decodezp.github.io/2019/08/11/diary-on-18th-b-day/"/>
    <id>https://decodezp.github.io/2019/08/11/diary-on-18th-b-day/</id>
    <published>2019-08-11T08:48:30.000Z</published>
    <updated>2019-08-11T08:49:56.476Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;上中学的时候，按历任语文老师的要求，写过好几本日记。这里面有一本是最不一样的，因为高三了，语文老师可能也认为“写日记”这个事确实太闲情逸致了一些，所以不再像以前一样要求上交日记本批改。我因此也得以在上面写了一些真正的日记。&lt;br&gt;
    
    </summary>
    
      <category term="thoughts" scheme="https://decodezp.github.io/categories/thoughts/"/>
    
    
      <category term="thoughts" scheme="https://decodezp.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>几句话说清楚32：Git命令极简使用指南</title>
    <link href="https://decodezp.github.io/2019/08/09/quickwords32-simplest-git-manual/"/>
    <id>https://decodezp.github.io/2019/08/09/quickwords32-simplest-git-manual/</id>
    <published>2019-08-09T13:23:45.000Z</published>
    <updated>2019-08-09T13:29:49.412Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本上可以Cover 90%以上的工作场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;要开始在现有Master上搞点什么&quot;&gt;&lt;a href=&quot;#要开始在现有Master上搞点什么&quot; class=&quot;headerlink&quot; title=&quot;要开始在现有Master上搞点什么&quot;&gt;&lt;/a&gt;要开始在现有Master上搞点什么&lt;/h2&gt;&lt;h3 id=&quot;确保你在master分支上&quot;&gt;&lt;a href=&quot;#确保你在master分支上&quot; class=&quot;headerlink&quot; title=&quot;确保你在master分支上&quot;&gt;&lt;/a&gt;确保你在master分支上&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git checkout master&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去18：使用LD_PRELOAD搞砸一切</title>
    <link href="https://decodezp.github.io/2019/08/09/test18-ld-preload-mess-up/"/>
    <id>https://decodezp.github.io/2019/08/09/test18-ld-preload-mess-up/</id>
    <published>2019-08-08T21:19:53.000Z</published>
    <updated>2019-08-08T21:22:32.702Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LD-PRELOAD&quot;&gt;&lt;a href=&quot;#LD-PRELOAD&quot; class=&quot;headerlink&quot; title=&quot;LD_PRELOAD&quot;&gt;&lt;/a&gt;LD_PRELOAD&lt;/h2&gt;&lt;p&gt;&lt;code&gt;LD_PRELOAD&lt;/code&gt;是一个神奇的指令，关于它的介绍可以参考这篇&lt;a href=&quot;http://www.goldsborough.me/c/low-level/kernel/2016/08/29/16-48-53-the_-ld_preload-_trick/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，这篇&lt;a href=&quot;https://catonmat.net/simple-ld-preload-tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去17：Adding dynamic probe to gain insight of DPDK application</title>
    <link href="https://decodezp.github.io/2019/08/07/test17-dyn-probe-dpdk/"/>
    <id>https://decodezp.github.io/2019/08/07/test17-dyn-probe-dpdk/</id>
    <published>2019-08-07T11:00:53.000Z</published>
    <updated>2019-08-07T11:02:23.302Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dynamic-Trace-Framework&quot;&gt;&lt;a href=&quot;#Dynamic-Trace-Framework&quot; class=&quot;headerlink&quot; title=&quot;Dynamic Trace Framework&quot;&gt;&lt;/a&gt;Dynamic Trace Framework&lt;/h2&gt;&lt;p&gt;曾经想给DPDK添加一个trace framework，但使用的方法是添加一个专门的rte_trace库，涉及一整套trace buffer和控制相关的操作，同时需要修改原本DPDK应用的代码，使用起来成本还是比较高的。在逐渐熟悉了&lt;code&gt;uprobe&lt;/code&gt;的操作之后，其实可以用uprobe完成绝大部分这个trace framework所做的工作，例如方法执行时间戳、方法参数、返回值、内部变量值的记录工作，并且有性能开销方面的保障。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>测来测去16：Adding new kprobe to ftrace tracing</title>
    <link href="https://decodezp.github.io/2019/07/19/test16-adding-new-kprobe/"/>
    <id>https://decodezp.github.io/2019/07/19/test16-adding-new-kprobe/</id>
    <published>2019-07-19T12:29:10.000Z</published>
    <updated>2019-07-19T12:30:11.824Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;添加ftrace新事件&quot;&gt;&lt;a href=&quot;#添加ftrace新事件&quot; class=&quot;headerlink&quot; title=&quot;添加ftrace新事件&quot;&gt;&lt;/a&gt;添加ftrace新事件&lt;/h2&gt;&lt;p&gt;Ftrace自己带很多事件，之前一直以为在内核方面ftrace的触角就到此为止了。今天才了解到kprobe也可以像uprobe一样自己动态定义一个出来。这样默认的ftrace没有的事件也就可以通过添加新kprobe事件的方式添加了。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://decodezp.github.io/categories/tech/"/>
    
    
      <category term="tech" scheme="https://decodezp.github.io/tags/tech/"/>
    
  </entry>
  
</feed>
