{"title":"DecodeZ","description":"刚日读经，柔日读史","language":null,"link":"https://decodezp.github.io","pubDate":"Sun, 22 Dec 2019 16:05:40 GMT","lastBuildDate":"Wed, 01 Jan 2020 16:03:26 GMT","generator":"hexo-generator-json-feed","webMaster":"Pan Zhang","items":[{"title":"几句话说清楚37:Skylake Non-inclusive缓存和Snoop Filter的关系","link":"https://decodezp.github.io/2019/12/23/quickwords37-skylake-cache-snoop-filter/","description":"Skylake的缓存设计使用了Non-inclusive的架构设计，同时调大了L2缓存的大小。简单来说，区别就是以前从内存读入的数据会同时进入L3和L2缓存，而现在会只进入L2缓存，当该数据从L2缓存中清除的时候，才会进入L3缓存。 在以前的缓存架构中，L2缓存中的数据是L3缓存数据的真子集。而Skylake的架构中，L2和L3的数据在绝大部分时间中是独占的(exclusive)的，即二者所缓存的数据没有重叠。但注意，Skylake的架构是Non-inclusive，而不是严格的exclusive，是因为当同一条Cache Line在多个CPU核的L2缓存中都存在时，L3缓存中也有该Cache Line的数据。","pubDate":"Sun, 22 Dec 2019 16:05:40 GMT","guid":"https://decodezp.github.io/2019/12/23/quickwords37-skylake-cache-snoop-filter/","category":"tech"},{"title":"怎样讲一个好故事","link":"https://decodezp.github.io/2019/12/22/thoughts12-how-to-make-a-good-story/","description":"人的一切知识和学问都是从故事中获取的。讲故事不仅仅是人类传承知识和文化的手段，同时也是获得理解和支持的最有效的方式。并且，一个经过设计(Engineered)的故事具备以虚驭实的能力，这种一种让人着迷的力量。怎样讲出一个好的故事，就是这篇文章想要讲的故事。 所有故事都有一个开头，这个开头的作用不在于交代背景，也不在于用离奇的描述“抓住眼球”，而在于将读者代入到故事中去。一定要出现读者所熟悉的元素、符号、场景和经历，或者没有直接出现，但能够激发读者去联想，去自己的认知库中检索和关联的意象。","pubDate":"Sun, 22 Dec 2019 14:26:27 GMT","guid":"https://decodezp.github.io/2019/12/22/thoughts12-how-to-make-a-good-story/","category":"thoughts"},{"title":"快乐清单","link":"https://decodezp.github.io/2019/12/05/thoughts11-happiness-list/","description":"开始了一项早就打算开始的项目：把每天快乐的瞬间都记录下来。Google Drive中这个简单的Excel表格，被我命名为“快乐清单”。","pubDate":"Wed, 04 Dec 2019 23:08:49 GMT","guid":"https://decodezp.github.io/2019/12/05/thoughts11-happiness-list/","category":"thoughts"},{"title":"测来测去22：DPDK i40e fdir+rss+reta实现相同flow type不同input_set散列","link":"https://decodezp.github.io/2019/11/26/test22-fdir-rss-reta/","description":"问题i40e网卡，同样的flow type，比如RTE_ETH_FLOW_NONFRAG_IPV4_UDP，需求是某一特定Dst Port的报文到rx队列1，某一特定Src IP + Dst IP的报文到rx队列2，或其他类似的针对相同flow type的需求。","pubDate":"Tue, 26 Nov 2019 11:07:58 GMT","guid":"https://decodezp.github.io/2019/11/26/test22-fdir-rss-reta/","category":"tech"},{"title":"怎样做好市场工作","link":"https://decodezp.github.io/2019/11/17/thoughts10-how-to-do-marketing/","description":"市场工作是提高产品价值所要进行的最重要的工作。市场工作并不是围绕产品的工作，也不是围绕客户的工作，而是围绕符号的工作——构建关于一个特定符号的意象。这个符号代表你想要卖出去的东西，而意象的作用在于，它不会改变人们对你产品的认知，而是让人们改变对自我的认知，即便那只是一种想象。","pubDate":"Sun, 17 Nov 2019 09:34:32 GMT","guid":"https://decodezp.github.io/2019/11/17/thoughts10-how-to-do-marketing/","category":"thoughts"},{"title":"QuickWords 35： Perf probe usage","link":"https://decodezp.github.io/2019/11/07/quickwords35-perf-probe-usage/","description":"查看用户空间binary/.so文件可用函数 perf probe -F -x /usr/lib64/libopenvswitch-2.so.7.0.0 查看可以被probe的源码行","pubDate":"Thu, 07 Nov 2019 10:50:46 GMT","guid":"https://decodezp.github.io/2019/11/07/quickwords35-perf-probe-usage/","category":"tech"},{"title":"Loadbalancer Product Trends","link":"https://decodezp.github.io/2019/10/31/product2-loadbalancer-trends/","description":"So what is going on? There are mainly 4 kinds of work.","pubDate":"Thu, 31 Oct 2019 11:37:18 GMT","guid":"https://decodezp.github.io/2019/10/31/product2-loadbalancer-trends/","category":"tech,product"},{"title":"测来测去21：在ftrace中拿到event的user-space stack trace","link":"https://decodezp.github.io/2019/10/30/test21-uprobe-userstacktrace/","description":"问题在开启了ftrace中的一些事件之后，可以用function_graph的trace拿到在内核态的callstack。但有些时候我们希望能拿到用户态程序的callstack，这样我们就能知道是那些方法触发了某一事件，或者我们直接希望uprobe的事件发生时，能够看到该事件对应的callstack，也会是一个很有价值的信息。 阅读文档本来的计划是，搞一个什么ftrace callback的内核模块，模块里面调用一些save_stack_trace_user()这类的方法，但是感觉虽然理论上行得通，但是实际上系统里敢让你塞一个内核模块进去的企业太少，所以暂时先放弃这个方案。","pubDate":"Wed, 30 Oct 2019 11:24:43 GMT","guid":"https://decodezp.github.io/2019/10/30/test21-uprobe-userstacktrace/","category":"test"},{"title":"QuickWords 34： DPDK i40e 82599网卡发送Tx丢包问题","link":"https://decodezp.github.io/2019/10/17/quickwords34-dpdk-tx-hang/","description":"现象表现为在DPDK场景下网卡丢包或者发送队列Hang住。如果用GDB跟进去的话会发现是网卡的DD标志位未置位。","pubDate":"Wed, 16 Oct 2019 19:11:39 GMT","guid":"https://decodezp.github.io/2019/10/17/quickwords34-dpdk-tx-hang/","category":"tech"},{"title":"金罍深深酌","link":"https://decodezp.github.io/2019/10/12/leuven-mem/","description":"一2012年3月，我在布鲁塞尔南站7号站台见到了高中同学L。","pubDate":"Sat, 12 Oct 2019 12:33:29 GMT","guid":"https://decodezp.github.io/2019/10/12/leuven-mem/","category":"life"},{"title":"Shell命令行中感叹号!的运用","link":"https://decodezp.github.io/2019/09/25/exclamation-mark-shell/","description":"!!重复执行上一条命令直接输入!!，不过我更喜欢按上方向键…","pubDate":"Wed, 25 Sep 2019 12:10:27 GMT","guid":"https://decodezp.github.io/2019/09/25/exclamation-mark-shell/","category":"tech"},{"title":"热烈庆祝8总力克猫传腹病魔康复痊愈","link":"https://decodezp.github.io/2019/09/22/8-recovery/","description":"8总是今年3月出生的一只蓝白相间的英国短毛猫，因为脑袋上的蓝色花斑从中间裂开一个“八”字形的缝，因此被称为8总。","pubDate":"Sun, 22 Sep 2019 10:50:13 GMT","guid":"https://decodezp.github.io/2019/09/22/8-recovery/","category":"thoughts"},{"title":"测来测去20：快速定位short-lived进程对性能的负面影响","link":"https://decodezp.github.io/2019/09/19/test20-troubleshoot-short-lived-process/","description":"案例遇到过的一个案例是这样：DPDK应用在小流量的情况下丢包，并且是间歇性地丢。很自然的，会怀疑有其他进程抢占分配给DPDK的CPU核。","pubDate":"Wed, 18 Sep 2019 19:58:10 GMT","guid":"https://decodezp.github.io/2019/09/19/test20-troubleshoot-short-lived-process/","category":"test"},{"title":"测来测去19：Enable DPDK i40e vector rx function","link":"https://decodezp.github.io/2019/09/04/test19-enable-dpdk-i40e-vector-rx-function/","description":"Vector Rx Function在DPDK i40e网卡的驱动中提供有利用向量指令收包的方法，在一般场景下可以大幅提升性能。当针对基于DPDK的应用做性能诊断时可以用perf top命令直观观察有没有i40e_recv_pkts_vec这个方法出现，如果没有则可以判定当前的应用没有使用向量指令集优化过的收/发包方法。","pubDate":"Wed, 04 Sep 2019 11:22:57 GMT","guid":"https://decodezp.github.io/2019/09/04/test19-enable-dpdk-i40e-vector-rx-function/","category":"tech"},{"title":"Quickwords33:How uprobe works","link":"https://decodezp.github.io/2019/08/25/quickwords33-how-uprobe-work/","description":"背景用uprobe也有一段时间了，确实是一个很有价值的工具。我这个人有个特点，就是如果不知道这件事背后的原理，即便工具很好用，但用起来始终心里不踏实，像是房本上没加名字，住着没有安全感。对于uprobe这么fancy的工具还是很有必要了解一下具体的工作机制。一方面是打消“神秘感”，一方面是看看是否能激发别的灵感。","pubDate":"Sun, 25 Aug 2019 14:07:45 GMT","guid":"https://decodezp.github.io/2019/08/25/quickwords33-how-uprobe-work/","category":"tech"},{"title":"十八岁这天的日记","link":"https://decodezp.github.io/2019/08/11/diary-on-18th-b-day/","description":"上中学的时候，按历任语文老师的要求，写过好几本日记。这里面有一本是最不一样的，因为高三了，语文老师可能也认为“写日记”这个事确实太闲情逸致了一些，所以不再像以前一样要求上交日记本批改。我因此也得以在上面写了一些真正的日记。","pubDate":"Sun, 11 Aug 2019 08:48:30 GMT","guid":"https://decodezp.github.io/2019/08/11/diary-on-18th-b-day/","category":"thoughts"},{"title":"几句话说清楚32：Git命令极简使用指南","link":"https://decodezp.github.io/2019/08/09/quickwords32-simplest-git-manual/","description":"基本上可以Cover 90%以上的工作场景。 要开始在现有Master上搞点什么确保你在master分支上git checkout master","pubDate":"Fri, 09 Aug 2019 13:23:45 GMT","guid":"https://decodezp.github.io/2019/08/09/quickwords32-simplest-git-manual/","category":"tech"},{"title":"测来测去18：使用LD_PRELOAD搞砸一切","link":"https://decodezp.github.io/2019/08/09/test18-ld-preload-mess-up/","description":"LD_PRELOADLD_PRELOAD是一个神奇的指令，关于它的介绍可以参考这篇文章，这篇文章。","pubDate":"Thu, 08 Aug 2019 21:19:53 GMT","guid":"https://decodezp.github.io/2019/08/09/test18-ld-preload-mess-up/","category":"tech"},{"title":"测来测去17：Adding dynamic probe to gain insight of DPDK application","link":"https://decodezp.github.io/2019/08/07/test17-dyn-probe-dpdk/","description":"Dynamic Trace Framework曾经想给DPDK添加一个trace framework，但使用的方法是添加一个专门的rte_trace库，涉及一整套trace buffer和控制相关的操作，同时需要修改原本DPDK应用的代码，使用起来成本还是比较高的。在逐渐熟悉了uprobe的操作之后，其实可以用uprobe完成绝大部分这个trace framework所做的工作，例如方法执行时间戳、方法参数、返回值、内部变量值的记录工作，并且有性能开销方面的保障。","pubDate":"Wed, 07 Aug 2019 11:00:53 GMT","guid":"https://decodezp.github.io/2019/08/07/test17-dyn-probe-dpdk/","category":"tech"},{"title":"测来测去16：Adding new kprobe to ftrace tracing","link":"https://decodezp.github.io/2019/07/19/test16-adding-new-kprobe/","description":"添加ftrace新事件Ftrace自己带很多事件，之前一直以为在内核方面ftrace的触角就到此为止了。今天才了解到kprobe也可以像uprobe一样自己动态定义一个出来。这样默认的ftrace没有的事件也就可以通过添加新kprobe事件的方式添加了。","pubDate":"Fri, 19 Jul 2019 12:29:10 GMT","guid":"https://decodezp.github.io/2019/07/19/test16-adding-new-kprobe/","category":"tech"},{"title":"测来测去15：DPDK VxLAN Inner L4 CSUM OFFLOAD","link":"https://decodezp.github.io/2019/07/16/test15-dpdk-vxlan-csum-offload/","description":"IXGBE以IXGBE驱动为例，看一下如何让把内层报文Checksum的计算Offload给网卡。 本质上来说，是在DPDK的mbuf结构中，将L2 Header的长度配置为外层VxLAN报文+内层L2 Header的总长度，这样对网卡来说，该mbuf对应的报文就是一个L2 Header长得令人发指的普通非隧道报文，但是这样就可以计算内层L3/L4 Header的Checksum了。","pubDate":"Tue, 16 Jul 2019 11:08:19 GMT","guid":"https://decodezp.github.io/2019/07/16/test15-dpdk-vxlan-csum-offload/","category":"test"},{"title":"Quickwords31：What Is Inclusive and Exclusive Cache","link":"https://decodezp.github.io/2019/07/08/quickwords31-inclusive-exclusive-cache/","description":"一般对Cache的认知方式我们比较熟悉的对Cache的理解是，首先有3级，L1，L2和L3。这三级依次远离CPU核心，查询数据的速度也依次减慢。当CPU需要一个地址上的数据时，会先去L1查找；当L1没有这个数据的时候，去L2查找；L2也没有的时候，去L3查找。如果还没有，就去内存上去查找。这是我们看待Cache和CPU查询数据时的一般方式。","pubDate":"Mon, 08 Jul 2019 13:10:13 GMT","guid":"https://decodezp.github.io/2019/07/08/quickwords31-inclusive-exclusive-cache/","category":"tech"},{"title":"应许之日","link":"https://decodezp.github.io/2019/06/24/promised-date/","description":"很庆幸自己能活这么久，站在此时此刻的人生节点上，可以闻到更好的时光还在后面。","pubDate":"Mon, 24 Jun 2019 14:05:19 GMT","guid":"https://decodezp.github.io/2019/06/24/promised-date/","category":"thoughts"},{"title":"5分钟经典英文技术演讲3：如何应对信息过载并提高生产效率-Scott Hanselman","link":"https://decodezp.github.io/2019/06/19/eng-talk3-scaling-yourself/","description":"一个人的能力上限很大程度上取决于他获取信息的能力。 而能力增长的速度与获取信息的质量正相关。 不可否认，大量优质的技术内容都基于英文。“5分钟经典英文技术演讲”专门撷取国外最有价值的纯英文技术演讲，以最精炼的形式将信息传达给国内的技术同侪，绕过网络政策和语言的障碍，实现中西方技术世界无壁垒的信息同步。 最新内容将发布于DecodeZ: decodezp.github.io 往期回顾1：如何快速掌握新技术往期回顾2：软件设计真正的精髓 GOTO2012: Scaling Yourself原视频 摘要：信息过载的时代，能否找到一种在信息洪流中独善其身的方法，让我们专注于真正重要事情？当生活/工作的范畴一再扩大，我们也需要延展自身的边界，在充分利用信息的同时，保持持续的生产效率。","pubDate":"Wed, 19 Jun 2019 12:04:22 GMT","guid":"https://decodezp.github.io/2019/06/19/eng-talk3-scaling-yourself/","category":"ENG_talk"},{"title":"Quickwords30：Use Both kprobe and uprobe At The Same Time","link":"https://decodezp.github.io/2019/06/18/quickwords30-kprobe-uprobe-both/","description":"用ftrace可以观察内核方法的调用信息。用uprobe可以观察用户空间二进制可执行文件中方法的调用信息。奇怪的是当你想把两个合在一起用的时候，比如你想看到内核调度器调度到了你关心的用户进程，同时也想知道调度之后，该进程会执行哪个方法的时候，网络上我没有找到任何资料教你如何去做。按说这应该是一个对各类系统问题诊断很有用的能力。 也许是太简单了？下面用一个示例说明。 内核版本12uname -r4.19.6-1.el7.elrepo.x86_64 有点新，不过不害事。","pubDate":"Tue, 18 Jun 2019 13:37:51 GMT","guid":"https://decodezp.github.io/2019/06/18/quickwords30-kprobe-uprobe-both/","category":"tech"}]}